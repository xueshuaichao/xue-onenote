 ## 一、基础背景
vue3.0中也对dom-diff算法进行了优化，其中就用到了 「最长递增子序列」。

在项目中，实际上我们编写的模板或者jsx语法会被@vue/compiler-dom转化为虚拟 DOM 节点，即 Virtual DOM，之后再将虚拟 DOM 节点渲染成实际的 DOM 节点。类似如下所示：



也许你会有个问题，为什么要引入虚拟DOM，而不是直接把组件转换成正式DOM节点呢？
- 具备跨平台的优势  
        由于虚拟DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等，是实现ssr、小程序等的基础。

- 提升渲染性能  
        因为DOM是一个很大的对象，直接操作DOM，即便是一个空的 div 也要付出昂贵的代价，执行速度远不如我们抽象出来的 Javascript 对象的速度快，因此，把大量的DOM操作搬运到 Javascript 中，运用diff算法来计算出真正需要更新的节点，最大限度地减少DOM操作，从而显著提高性能。虚拟DOM的优势不在于单次的操作，而是在大量、频繁的数据更新下，能够对视图进行合理、高效的更新。

- 虚拟DOM的应用  
根据上面的介绍，我们知道Vue会把我们编写的组件转换成虚拟DOM树，并且将虚拟DOM树进行比较后再根据变化情况更新真实DOM。比如原有列表为 
[a, b, c, d, e, f] ，而新列表为 
[a, d, b, c, e, f]， 这时会这样进行diff：

1.去除相同前置和后置元素  
 即双端Diff，可以比较容易实现而且带来带来比较明显的提升；
比如针对上情况，去除相同的前置和后置元素后，真正需要处理的是 [ b, c, d] 和 [d, b, c] ，复杂性会大大降低。

2.最长递增子序列  
接着要将原数组中的[ b, c, d] 转化成 [d, b, c] 。Vue3 中对移动次数进行了进一步的优化。下面对这个算法进行介绍：  
a.首先遍历新列表，通过 key 去查找在原有列表中的位置，从而得到新列表在原有列表中位置所构成的数组。比如原数组中的
[ b, c, d]， 新数组为 [d, b, c] ，得到的位置数组为 [3, 1, 2] ，现在的算法就是通过位置数组判断最小化移动次数；  
b.计算最长递增子序列  
最长递增子序列是经典的动态规划算法，不了解的可以前往 最长递增子序列 去补充一下前序知识。那么为什么最长递增子序列就可以保证移动次数最少呢？因为在位置数组中递增就能保证在旧数组中的相对位置的有序性，从而不需要移动，因此递增子序列的最长可以保证移动次数的最少

对于前面的得到的位置数组[3, 1, 2]，得到最长递增子序列 [1, 2] ，在子序列内的元素不移动，不在此子序列的元素移动即可。对应的实际的节点即 d 节点移动至b, c前面即可。











