
### 分析执行顺序
```js
 async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}

async function async2() {
  console.log("async2");
  await async3();
  console.log("async3 end");
  await async4();
  console.log("async2 end");
}

async function async3() {
  console.log("async3");
}

async function async4() {
  console.log("async4");
}

console.log("js start");

setTimeout(() => {
  console.log("timeout");
}, 0);

async1();

new Promise((resolve) => {
  console.log("promise");
  resolve("resolve");
})
  .then("then")
  .then((data) => {
    console.log(data);
  });

console.log("js end");
```


```js
async function asy1() {
    console.log(1);
    await asy2();
    console.log(2);
  }
  asy2 = async () => {
    await setTimeout((_) => {
      Promise.resolve().then((_) => {
        console.log(3);
      });
      console.log(4);
    }, 0);
  };
  asy3 = async () =>
    Promise.resolve().then(() => {
      console.log(6);
    });
  asy1();
  console.log(7);
  asy3();
  // 考察两个东西，一个promise，一个事件循环
  // 首先列出一张表，记录当前的宏任务和微任务队列
  //宏：空  微：空的
  // 首先打印1
  // 进入到asy2，这个函数只有一件事，在0秒后将回调函数归入到宏队列
  // todo 待整理

  https://www.bilibili.com/video/BV1Hu4y1s7oR/?spm_id_from=333.337.search-card.all.click&vd_source=31de9b6779fcb80b924201ff8967d829
      ```