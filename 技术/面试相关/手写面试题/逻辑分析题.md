
### 分析执行顺序
// 魔鬼在细节，一定要先同步执行完，这一步最容易拉东西，比如我第一次将js end丢了，
// 然后每一个方法都要执行到底，比如sync1方法就没执行到底
// 实战最重要，实战才能发现很多细节
```js
 async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}

async function async2() {
  console.log("async2");
  await async3();
  console.log("async3 end");
  await async4();
  console.log("async2 end");
}

async function async3() {
  console.log("async3");
}

async function async4() {
  console.log("async4");
}

console.log("js start");

setTimeout(() => {
  console.log("timeout");
}, 0);

async1();

new Promise((resolve) => {
  console.log("promise");
  resolve("resolve");
})
  .then("then")
  .then((data) => {
    console.log(data);
  });

console.log("js end");
```

### 分析题2
```js
async function asy1() {
    console.log(1);
    await asy2();
    console.log(2);
  }
  asy2 = async () => {
    await setTimeout((_) => {
      Promise.resolve().then((_) => {
        console.log(3);
      });
      console.log(4);
    }, 0);
  };
  asy3 = async () =>
    Promise.resolve().then(() => {
      console.log(6);
    });
  asy1();
  console.log(7);
  asy3();
  // 考察两个东西，一个promise，一个事件循环
  // 首先列出一张表，记录当前的宏任务和微任务队列
  //宏：空  微：空的
 // 注意点：当执行到await时，会将后边的代码放到微队列，如果后边没有，会将函数完成放到微队列

  https://www.bilibili.com/video/BV1Hu4y1s7oR/?spm_id_from=333.337.search-card.all.click&vd_source=31de9b6779fcb80b924201ff8967d829
```
>上边的再变一个形式，如果将asy2换成下边的，再分析下，
关键点：第一次执行时，第一个await算不算完成呢，当然没有，4还在微队列呢，只有都完成了，才算完成。
```js
  asy2 = async () => {
    await (async () => {
      await (() => {
        console.log(3)
      })()
      console.log(4)
    })()
  };
```




