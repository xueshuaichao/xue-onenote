
### 1.如何解决首次加载白屏的问题（ID:1730282219548）

首屏优化的首要原则是降低首屏体积

看是什么引起的，如果是兼容性问题导致的白屏，则捕捉上报，如果体积太大，

- 打包层面
按需加载
利用构建，压缩，tree-shaking  // 这个是王炸
gzip

- 网络层面：
1. 将大的静态图片放到cdn上，使用 CDN 加速，提高资源加载速度;
2. 使用浏览器缓存，减少重复加载资源的时间
3.优化了请求流程，将接口串行改为并行

- 代码层面
替换一些库，换成更小库，老版本替换新版本，比如vue2是不支持treeshaking的
不要什么都第三方库




### 如何做项目优化
- 打包层面：
按需加载
利用构建，压缩，tree-shaking  // 这个是王炸
gzip

- 网络层面：
1. 开启http缓存，减少资源的重复请求
2. 对http做统一的请求相应拦截，或者统一处理阻止重复提交之类的逻辑；
3. 开启cdn加速，增加资源的加载效率

- 代码层面
防止页面重复加载，用usecallback，usememo等
注意公共组件和公共方法的抽取，
图片懒加载，到可是区域再加载，
对长列表，使用虚拟列表
尽量的不要什么都第三方库



常见的有xss，csrf
 # 30、xss跨站脚本攻击如何进行？防御手段？
- 如何进行：xss是指恶意攻击者利用网站没有对用户提交的数据进行过滤处理，进而添加一些恶意代码，嵌入到Web页面，从而利用用户的身份进行某种动作  
- 防御手段：不信任客户端提交的任何数据，只要是客户端提交的就应该先进行对应的过滤处理。
1. 过滤特殊字符
避免XSS的方法之一主要是将用户所提供的内容进行过滤(如上面的script标签)。
1. 使用HTTP头指定类型  
`w.Header().Set("Content-Type","text/javascript")`
这样就可以让浏览器解析javascript代码，而不会是html输出。

### 31、CSRF(跨站请求伪造)如何进行？防御手段？

- 如何进行：利用用户在特定网站上的已登录状态，诱导用户在不知情的情况下执行攻击者一些预订的操作，
- 简单来说，攻击者通过受害者浏览器发送一些恶意请求，到受害者已经登录的网站，由于浏览器会自动携带这个网站的cookie，网站误认为请求是用户自己发的，
从而执行恶意的操作，比如转账，修改密码

防御手段：
1. 使用token验证，后端使用jwt技术验证token 
2. 增加验证码 
3. 使用post请求

### 32、web上传漏洞如何进行？防御手段？
- 如何进行：用户上传了一个可执行的脚本文件，并通过脚本文件获得了执行服务器端命令的能力
- 防御手段：
1. 前后端都对文件后缀名进行限制
2. 把文件上传目录的权限设置为只读

### 描述一下你最近完成的一个项目，包括技术实现和遇到的挑战
目的：了解你的技术能力，解决问题的方法以及你在团队中的协作方式
1.项目描述，比如说主播端
2.技术实现，用electron和react做的，以及用什么进行状态管理，以及哪些内容来处理样式
3.遇到的挑战，比如加载时间变得越来越长，为了解决这个问题，对代码进行分析，发现了一些不必要的数据渲染和数据请求是导致延迟的主要原因，我重构了一些组件，
并引入了懒加载和虚拟列表等技术，明显提高了这个页面的加载速度。

### 说一个比较有挑战的问题（所以说历史项目的总结也很重要，我之前都写到wiki上了，导致现在没了）（ID:1730368723174）
canvas渲染吧
需求是将ppt白板canvas通过canvasRef.captureStream(20)获取流，推到流服务器，因为canvas转成流的条件是要实时渲染，所以想到通过requestAnimationFrame实时拷贝到一张临时canvas上，但这样就导致性能问题，所以最后想到通过cxt.clearRect(0, 0, 1, 1)驱动白板实时更新，（实际场景中还和多人连麦一起出现，一开始以为是连麦人数太多导致的，比较难排查）


其实最经典的问题还是首屏优化


### 1、前端工程化理解
是一种让开发自动化、规范化的方式，解决一些纯人工的，非标准的问题，提升效率

包括  git，eslint
JS的模块化、css的模块化、
HTML规范、CSS规范、JS规范、
持续集成、自动化部署、自动化测试

什么叫ci/cd
ci：持续化集成，就是构建的意思
cd：持续化部署
有很多工具可以做到，比如jenkins，比如gitlab也有，比如github的actions也提供了相应的能力，就你提交了代码后，自动可以做到打包构建并部署到线上，当然需要配置deploy脚本文件
大伟聊前端

CI/CD 的实现
CI 的实现
代码风格检查
版本规范
Git 分支规范
自动化单元测试、端到端测试
…
保证失败可追溯
测试结果通知
Changelog记录
Code Review机制
…
CD 的实现
持续交付
多种级别的测试环境
QA团队对功能测试的快速响应
自动化测试覆盖率的检查
发布流程的标准化
…
持续部署
完善的项目迭代机制
渐进式的发布策略
线上监控告警
快速回滚能力
 


说一下前端工程化
https://blog.csdn.net/weixin_56650035/article/details/128886558



### 做过哪些性能优化相关的事 （ID:1740618291848）
下边说的比较多，先说这3点把
1.长列表优化
2.懒加载
3.防止页面重复加载，用usecallback，usememo等

## 1. 代码优化
1. 减少HTTP请求：合并CSS和JavaScript文件，使用图像精灵（Sprite）等。
2. 代码压缩和混淆：使用工具如UglifyJS、Terser等压缩和混淆JavaScript代码，使用CSS压缩工具如cssnano。
3. 删除未使用的代码：使用工具如PurgeCSS来删除未使用的CSS，使用Tree Shaking来删除未使用的JavaScript代码。
## 2. 图片优化
1. 图像压缩：使用工具如ImageOptim、TinyPNG等压缩图像文件。
2. 使用现代图像格式：如WebP，具有更好的压缩率。
3. 延迟加载（Lazy Loading）：仅在需要时加载图像，减少初始加载时间。
## 3. 网络优化
1. 使用CDN：将静态资源托管在内容分发网络（CDN）上，减少延迟。
2. 启用HTTP/2：HTTP/2支持多路复用，可以显著提高加载速度。
3. 缓存策略：使用浏览器缓存、服务端缓存（如Redis）等，减少重复请求。
## 4. 渲染优化
1. 减少重排和重绘：尽量减少对DOM的操作，使用DocumentFragment进行批量DOM操作。
2. 使用CSS3硬件加速：如使用transform、opacity等属性，避免使用top、left等会触发重排的属性。
3. 虚拟DOM：使用React、Vue等框架的虚拟DOM机制，减少直接操作真实DOM的次数。
## 5. JavaScript优化
1. 异步加载JavaScript：使用async或defer属性异步加载JavaScript文件，避免阻塞页面渲染。
2. 代码分割：使用Webpack等工具进行代码分割，按需加载模块。
3. 减少全局变量：避免全局变量污染，减少命名冲突。
## 6. CSS优化
1. 避免使用@import：使用@import会阻塞页面渲染，尽量使用<link>标签引入CSS。
2. 使用CSS预处理器：如Sass、Less等，组织和管理CSS代码，提高可维护性。
3. 关键渲染路径优化：将关键CSS内联到HTML中，减少首次渲染时间。
## 7. 其他优化
- 使用Service Worker：实现离线缓存，提高应用的可用性和性能。
- 预加载和预取：使用<link rel="preload">和<link rel="prefetch">标签预加载关键资源。
- 性能监控和分析：使用工具如Lighthouse、WebPageTest、Chrome DevTools等进行性能监控和分析，找出瓶颈并优化。
- 在面试中，除了列举这些优化方法，还可以结合你实际参与的项目，具体说明你是如何应用这些优化技术的，以及它们带来的性能提升效果。这样可以更好地展示你的实际经验和能力。
